---
name: Weekly Infrastructure Maintenance

on:
  schedule:
    # Run every Saturday at 6:00 AM UTC
    - cron: '0 6 * * 6'
  workflow_dispatch:
    inputs:
      skip_tls_verify:
        description: 'Skip TLS verification for K8s'
        required: false
        default: true
        type: boolean
      dry_run:
        description: 'Run in check mode (dry run)'
        required: false
        default: false
        type: boolean

jobs:
  sequential-maintenance:
    name: Sequential Infrastructure Maintenance (K8s â†’ Docker)
    runs-on: self-hosted  # Use your local runner
    timeout-minutes: 300  # 5 hours timeout for complete sequential maintenance
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Set up environment variables
        run: |
          # Set 1Password service account token (no output to avoid logging)
          if [ -f /home/ansible/scripts/op-signin/op_token ]; then
            echo "OP_SERVICE_ACCOUNT_TOKEN=$(cat /home/ansible/scripts/op-signin/op_token)" >> $GITHUB_ENV
            echo "âœ… 1Password service account token loaded"
          else
            echo "âŒ 1Password token file not found"
            exit 1
          fi
          
          # Set maintenance timestamp
          echo "MAINTENANCE_START=$(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
          echo "WORKFLOW_ID=${{ github.run_id }}" >> $GITHUB_ENV
          
          # Ensure SSH agent is available and keys are loaded
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "ðŸ”‘ SSH agent status:"
          ssh-add -l || echo "No SSH keys loaded, will use default SSH configuration"
      
      - name: Load SSH keys for remote connections
        run: |
          # Start SSH agent if not already running
          if [ -z "$SSH_AUTH_SOCK" ]; then
            eval $(ssh-agent -s)
            echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
            echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV
          fi
          
          # Add all available SSH keys
          echo "ðŸ”‘ Loading SSH keys for remote host connections..."
          ssh-add ~/.ssh/id_* 2>/dev/null || echo "Using default SSH key configuration"
          
          # Verify SSH keys are available
          echo "ðŸ“‹ Available SSH keys:"
          ssh-add -l || echo "Will use SSH config and default keys"
          
          # Test SSH config is working
          echo "ðŸ”§ SSH configuration ready for remote host connections"
      
      - name: Install/Update Ansible Collection
        run: |
          # Install the latest version of the collection
          ansible-galaxy collection install gregheffner.ubuntu_patching --force
          echo "âœ… Collection installed/updated successfully"
      
      - name: Verify inventory and connectivity
        run: |
          echo "ðŸ” Testing connectivity to all hosts using local SSH keys..."
          
          # Test K8s cluster connectivity (no sensitive output)
          echo "Testing K8s cluster hosts:"
          if ANSIBLE_HOST_KEY_CHECKING=False \
             ANSIBLE_SSH_ARGS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" \
             ansible k8s_cluster -i inventory/hosts.ini -m ping --one-line > /dev/null 2>&1; then
            echo "âœ… K8s cluster hosts reachable"
          else
            echo "âŒ K8s cluster connectivity failed"
            exit 1
          fi
          
          # Test Docker host connectivity (no sensitive output)
          echo "Testing Docker hosts:"
          if ANSIBLE_HOST_KEY_CHECKING=False \
             ANSIBLE_SSH_ARGS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" \
             ansible docker -i inventory/hosts.ini -m ping --one-line > /dev/null 2>&1; then
            echo "âœ… Docker hosts reachable"
          else
            echo "âŒ Docker host connectivity failed"
            exit 1
          fi
          
          echo "âœ… All hosts are reachable via SSH"
      
      - name: Run Sequential Infrastructure Maintenance
        id: maintenance
        run: |
          set -e  # Exit on any error
          
          echo "ðŸš€ Starting Full Sequential Infrastructure Maintenance"
          echo "Phase 1: K8s Cluster Maintenance"
          echo "Phase 2: Docker Host Maintenance"
          echo ""
          
          # Determine run mode
          if [ "${{ inputs.dry_run }}" == "true" ]; then
            CHECK_MODE="--check"
            echo "ðŸ§ª Running in DRY RUN mode (no actual changes)"
          else
            CHECK_MODE=""
            echo "ðŸ”§ Running LIVE maintenance (making actual changes)"
          fi
          
          # Set TLS verification for K8s
          if [ "${{ inputs.skip_tls_verify }}" == "true" ]; then
            TLS_VERIFY="k8s_skip_tls_verify=true"
            echo "âš ï¸  Skipping TLS verification for K8s API"
          else
            TLS_VERIFY="k8s_skip_tls_verify=false"
            echo "ðŸ”’ Using TLS verification for K8s API"
          fi
          
          echo ""
          echo "ðŸ”‘ Using local SSH keys for remote host connections"
          echo "â–¶ï¸  Executing full sequential maintenance..."
          
          # Execute the maintenance playbook with limited output and SSH configuration
          if ANSIBLE_HOST_KEY_CHECKING=False \
             ANSIBLE_SSH_ARGS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" \
             ansible-playbook sequential_maintenance.yml \
             -i inventory/hosts.ini \
             --extra-vars "$TLS_VERIFY" \
             $CHECK_MODE \
             --one-line > /tmp/maintenance_summary.log 2>&1; then
            echo "âœ… Sequential maintenance completed successfully!"
            # Show only summary, not sensitive details
            echo "ðŸ“Š Maintenance Summary:"
            grep -E "(PLAY RECAP|ok=|changed=|failed=)" /tmp/maintenance_summary.log | head -10 || echo "Summary not available"
          else
            echo "âŒ Sequential maintenance failed!"
            # Show only error indicators, not sensitive details
            echo "ðŸ“Š Error Summary:"
            grep -E "(fatal|FAILED|ERROR)" /tmp/maintenance_summary.log | head -5 || echo "Error details logged locally"
            exit 1
          fi
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ env.OP_SERVICE_ACCOUNT_TOKEN }}
      
      - name: Generate maintenance report
        if: always()  # Run even if previous steps failed
        run: |
          # Create a comprehensive maintenance report
          cat > maintenance-report.md << EOF
          # Sequential Infrastructure Maintenance Report
          
          **Date:** ${{ env.MAINTENANCE_START }}  
          **Workflow ID:** ${{ github.run_id }}  
          **Status:** ${{ job.status }}  
          **Runner:** $(hostname)  
          **Repository:** ${{ github.repository }}  
          **Branch:** ${{ github.ref_name }}  
          
          ## Maintenance Phases
          
          ### Phase 1: K8s Cluster Maintenance
          - **Target:** k8s_cluster group
          - **Actions:** System updates, node draining, reboots, monitor management
          - **Serial execution:** One node at a time for safety
          
          ### Phase 2: Docker Host Maintenance  
          - **Target:** docker group
          - **Actions:** System updates, Docker container management, reboots
          - **Execution:** After K8s cluster maintenance completion
          
          ## Configuration
          - **TLS Verification:** ${{ inputs.skip_tls_verify == 'true' && 'Disabled' || 'Enabled' }}
          - **Run Mode:** ${{ inputs.dry_run == 'true' && 'Dry Run (Check Mode)' || 'Live Maintenance' }}
          - **Timeout:** 5 hours
          - **Security:** Sensitive logs excluded from uploads
          
          ## Status
          - **Result:** ${{ job.status }}
          - **Summary:** Basic statistics only (no sensitive data)
          EOF
          
          # Add timestamp to log
          echo "[${{ env.MAINTENANCE_START }}] Maintenance report generated (ID: ${{ github.run_id }})" >> /mnt/QNAP/backuplogs/ansible-automation.log

      - name: Upload maintenance report only (no sensitive logs)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: maintenance-report-${{ github.run_number }}
          path: |
            maintenance-report.md
          retention-days: 7  # Shorter retention for security

      - name: Cleanup sensitive temporary files
        if: always()
        run: |
          # Remove any temporary files that might contain sensitive data
          rm -f /tmp/maintenance_summary.log
          rm -f /tmp/k8s_maintenance.log 
          rm -f /tmp/docker_maintenance.log
          rm -f /tmp/ansible-*.log
          echo "ðŸ§¹ Cleaned up temporary files"

  notify-completion:
    name: Send Notification
    needs: sequential-maintenance
    runs-on: self-hosted
    if: always()  # Run even if maintenance failed
    
    steps:
      - name: Send completion notification
        run: |
          if [ "${{ needs.sequential-maintenance.result }}" == "success" ]; then
            STATUS="âœ… SUCCESS"
            MESSAGE="Sequential infrastructure maintenance completed successfully"
            EMOJI="ðŸŽ‰"
          else
            STATUS="âŒ FAILED" 
            MESSAGE="Sequential infrastructure maintenance failed - check logs"
            EMOJI="ðŸš¨"
          fi
          
          # Comprehensive log entry
          cat >> /mnt/QNAP/backuplogs/ansible-automation.log << EOF
          [$(date '+%Y-%m-%d %H:%M:%S')] === WEEKLY MAINTENANCE SUMMARY ===
          Status: $STATUS
          Message: $MESSAGE  
          Workflow: ${{ github.run_id }}
          Duration: ${{ github.event.workflow_run.duration || 'Unknown' }}
          Runner: $(hostname)
          ================================================================
          EOF
          
          echo "$EMOJI $MESSAGE"
          
          # You can add email/Slack/webhook notifications here
          # Example webhook notification:
          # curl -X POST "YOUR_WEBHOOK_URL" \
          #   -H "Content-Type: application/json" \
          #   -d "{\"text\": \"$EMOJI $MESSAGE\"}"