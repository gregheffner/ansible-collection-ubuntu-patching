---
name: Weekly Infrastructure Maintenance

on:
  schedule:
    # Run every Saturday at 6:00 AM UTC
    - cron: '0 6 * * 6'
  workflow_dispatch:
    inputs:
      skip_tls_verify:
        description: 'Skip TLS verification for K8s'
        required: false
        default: true
        type: boolean
      dry_run:
        description: 'Run in check mode (dry run)'
        required: false
        default: false
        type: boolean

jobs:
  sequential-maintenance:
    name: Sequential Infrastructure Maintenance
    runs-on: self-hosted  # Use your local runner
    timeout-minutes: 300  # 5 hours timeout for complete sequential maintenance
    outputs:
      k8s_status: ${{ steps.k8s_maintenance.outcome }}
      docker_status: ${{ steps.docker_maintenance.outcome }}
      overall_status: ${{ job.status }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Mask sensitive values
        run: |
          # Mask common patterns that might contain API keys
          echo "::add-mask::ops_ey"
          echo "::add-mask::dd_"
          echo "::add-mask::api_key"
          echo "::add-mask::app_key"
          echo "Sensitive value patterns masked"
      
      - name: Set up environment variables
        run: |
          # Set 1Password service account token (no output to avoid logging)
          if [ -f /home/ansible/scripts/op-signin/op_token ]; then
            TOKEN=$(cat /home/ansible/scripts/op-signin/op_token)
            echo "::add-mask::$TOKEN"
            echo "OP_SERVICE_ACCOUNT_TOKEN=$TOKEN" >> $GITHUB_ENV
            echo "1Password service account token loaded (masked)"
          else
            echo "1Password token file not found"
            exit 1
          fi
          
          # Set maintenance timestamp
          echo "MAINTENANCE_START=$(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
          echo "WORKFLOW_ID=${{ github.run_id }}" >> $GITHUB_ENV
          
          # Ensure SSH agent is available and keys are loaded
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH agent status:"
          ssh-add -l || echo "No SSH keys loaded, will use default SSH configuration"
      
      - name: Load SSH keys for remote connections
        run: |
          # Start SSH agent if not already running
          if [ -z "$SSH_AUTH_SOCK" ]; then
            eval $(ssh-agent -s)
            echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
            echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV
          fi
          
          # Add all available SSH keys
          ssh-add ~/.ssh/id_* 2>/dev/null || echo "Using default SSH configuration"
          echo "SSH keys loaded for remote connections"
      
      - name: Install/Update Ansible Collection
        run: |
          # Build and install the local collection
          ansible-galaxy collection build --force
          
          # Install from local tarball to ensure we use the current code
          COLLECTION_FILE=$(ls gregheffner-ubuntu_patching-*.tar.gz | sort -V | tail -n 1)
          ansible-galaxy collection install "$COLLECTION_FILE" --force
          
          echo "Collection installed successfully"
      
      - name: Verify connectivity
        run: |
          # Test K8s cluster connectivity 
          if ansible k8s_cluster -m ping --one-line > /dev/null 2>&1; then
            echo "K8s cluster hosts reachable"
          else
            echo "K8s cluster connectivity failed"
            exit 1
          fi
          
          # Test Docker host connectivity
          if ansible dockerhost -m ping --one-line > /dev/null 2>&1; then
            echo "Docker host reachable"
          else
            echo "Docker host connectivity failed"
            exit 1
          fi
          
          echo "All hosts reachable"
      
      - name: Run K8s Cluster Maintenance (Phase 1)
        id: k8s_maintenance
        run: |
          set -e  # Exit on any error
          
          echo "Phase 1: K8s Cluster Maintenance"
          
          # Determine run mode
          if [ "${{ inputs.dry_run }}" == "true" ]; then
            CHECK_MODE="--check"
            echo "Running in DRY RUN mode"
          else
            CHECK_MODE=""
            echo "Running LIVE maintenance"
          fi
          
          # Set TLS verification for K8s
          if [ "${{ inputs.skip_tls_verify }}" == "true" ]; then
            TLS_VERIFY="k8s_skip_tls_verify=true"
          else
            TLS_VERIFY="k8s_skip_tls_verify=false"
          fi
          
          # Create K8s-only playbook temporarily
          cat > k8s_maintenance_only.yml << 'EOF'
          ---
          - name: K8s Cluster Maintenance Only
            hosts: k8s_cluster
            become: yes
            gather_facts: yes
            serial: 1  # One node at a time for safety
            
            tasks:
              - name: Run K8s maintenance role
                include_role:
                  name: gregheffner.ubuntu_patching.k8_maintenance
                vars:
                  pause_monitors_enabled: true
                  k8s_skip_tls_verify: "{{ k8s_skip_tls_verify | default(true) }}"
          EOF
          
          echo "K8s playbook created, executing..."
          
          # Execute the K8s maintenance playbook
          if ANSIBLE_HOST_KEY_CHECKING=False \
             ANSIBLE_SSH_ARGS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" \
             OP_SERVICE_ACCOUNT_TOKEN="${{ env.OP_SERVICE_ACCOUNT_TOKEN }}" \
             ansible-playbook k8s_maintenance_only.yml \
             --extra-vars "$TLS_VERIFY" \
             $CHECK_MODE > /home/ansible/k8s_maintenance.log 2>&1; then
            echo "K8s cluster maintenance completed successfully!"
          else
            echo "K8s cluster maintenance failed!"
            exit 1
          fi

      - name: Generate K8s Maintenance Report
        if: always()  # Run even if K8s maintenance failed
        run: |
          # Create intermediate report after K8s maintenance
          cat > k8s-maintenance-report.md << EOF
          # K8s Cluster Maintenance Report (Phase 1)
          
          **Date:** ${{ env.MAINTENANCE_START }}  
          **Workflow ID:** ${{ github.run_id }}  
          **Phase:** K8s Cluster Maintenance  
          **Status:** ${{ steps.k8s_maintenance.outcome }}  
          
          ## K8s Cluster Actions Completed
          - System updates on all K8s nodes
          - Kubernetes node draining and uncordoning
          - Datadog monitor management (pause/unpause)
          - Serial execution (one node at a time)
          
          ## Configuration
          - **TLS Verification:** ${{ inputs.skip_tls_verify == 'true' && 'Disabled' || 'Enabled' }}
          - **Run Mode:** ${{ inputs.dry_run == 'true' && 'Dry Run (Check Mode)' || 'Live Maintenance' }}
          
          ## Next Phase
          Phase 2 (Docker Host Maintenance) will begin after this report upload.
          EOF

      - name: Upload K8s Maintenance Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: k8s-maintenance-report-${{ github.run_number }}
          path: k8s-maintenance-report.md
          retention-days: 7

      - name: Schedule Docker Host Maintenance (Phase 2)
        id: docker_maintenance
        run: |
          echo "Phase 2: Docker Host Maintenance"
          
          # Determine run mode
          if [ "${{ inputs.dry_run }}" == "true" ]; then
            CHECK_MODE="--check"
            echo "Running in DRY RUN mode"
          else
            CHECK_MODE=""
            echo "Running LIVE maintenance (will reboot host)"
          fi
          
          # Create Docker-only playbook
          cat > docker_maintenance_only.yml << 'EOF'
          ---
          - name: Docker Host Maintenance Only
            hosts: dockerhost
            become: yes
            gather_facts: yes
            
            tasks:
              - name: Run Docker host maintenance role
                include_role:
                  name: gregheffner.ubuntu_patching.ubuntu_update
                vars:
                  reboot_enabled: true
          EOF
          
          echo "Docker playbook created"
          echo "Docker host maintenance will complete independently"
          echo "Final report will be generated after reboot (if live mode)"
          
          # Create completion marker before starting docker maintenance
          echo "DOCKER_MAINTENANCE_STARTED=$(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
          
          # Pre-create final report since we might not be able to finish the workflow
          cat > docker-maintenance-report.md << EOF
          # Docker Host Maintenance Report (Phase 2)
          
          **Date:** ${{ env.MAINTENANCE_START }}  
          **Docker Phase Started:** $(date '+%Y-%m-%d %H:%M:%S')
          **Workflow ID:** ${{ github.run_id }}  
          **Phase:** Docker Host Maintenance  
          
          ## Docker Host Actions
          - System updates on Docker host
          - Docker container management during updates
          - Host reboot (if live mode)
          
          ## Status
          Docker host maintenance was initiated. If running in live mode, 
          the runner host will reboot and this workflow will terminate.
          Check system logs post-reboot for completion status.
          
          ## Configuration
          - **Run Mode:** ${{ inputs.dry_run == 'true' && 'Dry Run (Check Mode)' || 'Live Maintenance (Will Reboot)' }}
          EOF
          
          # Execute the Docker maintenance playbook
          # In live mode, this may cause the runner to reboot and workflow to terminate
          if ANSIBLE_HOST_KEY_CHECKING=False \
             ANSIBLE_SSH_ARGS="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no" \
             OP_SERVICE_ACCOUNT_TOKEN="${{ env.OP_SERVICE_ACCOUNT_TOKEN }}" \
             ansible-playbook docker_maintenance_only.yml \
             $CHECK_MODE > /home/ansible/docker_maintenance.log 2>&1; then
            echo "Docker host maintenance completed!"
          else
            echo "Docker host maintenance failed or was interrupted by reboot"
          fi

      - name: Upload Docker Maintenance Report  
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: docker-maintenance-report-${{ github.run_number }}
          path: docker-maintenance-report.md
          retention-days: 7
      
      - name: Generate final maintenance report
        if: always()  # Run even if previous steps failed
        run: |
          # Create a comprehensive maintenance report
          cat > maintenance-report.md << EOF
          # Sequential Infrastructure Maintenance Report - COMPLETE
          
          **Date:** ${{ env.MAINTENANCE_START }}  
          **Workflow ID:** ${{ github.run_id }}  
          **Final Status:** ${{ job.status }}  
          **Runner:** $(hostname)  
          **Repository:** ${{ github.repository }}  
          **Branch:** ${{ github.ref_name }}  
          
          ## Maintenance Phases Completed
          
          ### Phase 1: K8s Cluster Maintenance âœ…
          - **Target:** k8s_cluster group (k8-primary, worker1, worker2, worker3)
          - **Status:** ${{ steps.k8s_maintenance.outcome }}
          - **Actions:** System updates, node draining, reboots, monitor management
          - **Serial execution:** One node at a time for safety
          
          ### Phase 2: Docker Host Maintenance 
          - **Target:** dockerhost group
          - **Status:** ${{ steps.docker_maintenance.outcome }}
          - **Actions:** System updates, Docker container management, reboots
          - **Note:** ${{ inputs.dry_run == 'true' && 'Dry run completed' || 'May have rebooted runner host' }}
          
          ## Configuration
          - **TLS Verification:** ${{ inputs.skip_tls_verify == 'true' && 'Disabled' || 'Enabled' }}
          - **Run Mode:** ${{ inputs.dry_run == 'true' && 'Dry Run (Check Mode)' || 'Live Maintenance' }}
          - **Timeout:** 5 hours
          - **Security:** Sensitive logs excluded from uploads
          
          ## Final Status
          - **K8s Result:** ${{ steps.k8s_maintenance.outcome }}
          - **Docker Result:** ${{ steps.docker_maintenance.outcome }}
          - **Overall:** ${{ job.status }}
          - **Reports Generated:** Individual phase reports + this summary
          
          ## Post-Maintenance Notes
          ${{ inputs.dry_run == 'true' && 'This was a dry run - no actual changes were made.' || 'Live maintenance completed. Verify all services are running properly.' }}
          EOF
          
          # Add timestamp to log
          echo "[${{ env.MAINTENANCE_START }}] Sequential maintenance completed (ID: ${{ github.run_id }}) - K8s: ${{ steps.k8s_maintenance.outcome }}, Docker: ${{ steps.docker_maintenance.outcome }}" >> /mnt/QNAP/backuplogs/ansible-automation.log

      - name: Upload final maintenance report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: final-maintenance-report-${{ github.run_number }}
          path: |
            maintenance-report.md
          retention-days: 7  # Shorter retention for security

      - name: Cleanup sensitive temporary files
        if: always()
        run: |
          # Remove any temporary files that might contain sensitive data
          rm -f /home/ansible/k8s_maintenance.log
          rm -f /home/ansible/docker_maintenance.log
          rm -f /home/ansible/ansible-*.log
          rm -f k8s_maintenance_only.yml
          rm -f docker_maintenance_only.yml
          echo "Cleanup completed"

  notify-completion:
    name: Send Notification
    needs: sequential-maintenance
    runs-on: self-hosted
    if: always()  # Run even if maintenance failed
    
    steps:
      - name: Send completion notification
        run: |
          # Determine overall status based on both phases
          K8S_STATUS="${{ needs.sequential-maintenance.outputs.k8s_status || 'unknown' }}"
          DOCKER_STATUS="${{ needs.sequential-maintenance.outputs.docker_status || 'unknown' }}"
          OVERALL_STATUS="${{ needs.sequential-maintenance.result }}"
          
          if [ "$OVERALL_STATUS" == "success" ]; then
            STATUS="SUCCESS"
            MESSAGE="Sequential infrastructure maintenance completed - K8s: $K8S_STATUS, Docker: $DOCKER_STATUS"
          elif [ "$OVERALL_STATUS" == "failure" ]; then
            STATUS="FAILED" 
            MESSAGE="Sequential infrastructure maintenance failed - K8s: $K8S_STATUS, Docker: $DOCKER_STATUS"
          else
            STATUS="PARTIAL"
            MESSAGE="Sequential infrastructure maintenance partially completed - check individual phase reports"
          fi
          
          # Check for dry run mode
          DRY_RUN_NOTE=""
          if [ "${{ github.event.inputs.dry_run }}" == "true" ]; then
            DRY_RUN_NOTE=" (DRY RUN - no changes made)"
          fi
          
          # Comprehensive log entry
          cat >> /mnt/QNAP/backuplogs/ansible-automation.log << EOF
          [$(date '+%Y-%m-%d %H:%M:%S')] === WEEKLY MAINTENANCE SUMMARY ===
          Status: $STATUS$DRY_RUN_NOTE
          K8s Phase: $K8S_STATUS  
          Docker Phase: $DOCKER_STATUS
          Message: $MESSAGE  
          Workflow: ${{ github.run_id }}
          Duration: Started ${{ github.event.workflow_run.started_at || github.event.head_commit.timestamp }}
          Runner: $(hostname)
          Reports: K8s + Docker + Final reports uploaded to GitHub
          ================================================================
          EOF
          
          echo "$MESSAGE$DRY_RUN_NOTE"
          
          # Note about runner host reboot in live mode
          if [ "${{ github.event.inputs.dry_run }}" != "true" ]; then
            echo "Note: If docker host maintenance ran in live mode, the runner may have rebooted"
            echo "   Check post-reboot logs for docker host maintenance completion status"
          fi